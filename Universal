local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local Camera = workspace.CurrentCamera
local GuiService = game:GetService("GuiService")
local HttpService = game:GetService("HttpService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")

local correctKey = "wyattisgay123"
local keyVerified = false

local function createKeyPrompt()
    local keyGui = Instance.new("ScreenGui")
    keyGui.Name = "DeXKeyPrompt"
    keyGui.Parent = CoreGui
    keyGui.ResetOnSpawn = false
    keyGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local mainFrame = Instance.new("Frame")  
    mainFrame.Name = "MainFrame"  
    mainFrame.Parent = keyGui  
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)  
    mainFrame.BorderSizePixel = 0  
    mainFrame.Position = UDim2.new(0.5, -200, 0.5, -100)  
    mainFrame.Size = UDim2.new(0, 400, 0, 200)  
    mainFrame.ClipsDescendants = true  
    
    local mainCorner = Instance.new("UICorner")  
    mainCorner.CornerRadius = UDim.new(0, 12)  
    mainCorner.Parent = mainFrame  
    
    local gradient = Instance.new("UIGradient")  
    gradient.Color = ColorSequence.new{  
        ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),  
        ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))  
    }  
    gradient.Rotation = 45  
    gradient.Parent = mainFrame  
    
    local title = Instance.new("TextLabel")  
    title.Name = "Title"  
    title.Parent = mainFrame  
    title.BackgroundTransparency = 1  
    title.Position = UDim2.new(0, 0, 0, 20)  
    title.Size = UDim2.new(1, 0, 0, 40)  
    title.Font = Enum.Font.GothamBold  
    title.Text = "DeX Authentication"  
    title.TextColor3 = Color3.fromRGB(255, 255, 255)  
    title.TextSize = 20  
    title.TextXAlignment = Enum.TextXAlignment.Center  
    
    local subtitle = Instance.new("TextLabel")  
    subtitle.Name = "Subtitle"  
    subtitle.Parent = mainFrame  
    subtitle.BackgroundTransparency = 1  
    subtitle.Position = UDim2.new(0, 0, 0, 60)  
    subtitle.Size = UDim2.new(1, 0, 0, 20)  
    subtitle.Font = Enum.Font.Gotham  
    subtitle.Text = "Enter your access key to continue"  
    subtitle.TextColor3 = Color3.fromRGB(200, 200, 200)  
    subtitle.TextSize = 14  
    subtitle.TextXAlignment = Enum.TextXAlignment.Center  
    
    local inputBox = Instance.new("TextBox")  
    inputBox.Name = "InputBox"  
    inputBox.Parent = mainFrame  
    inputBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)  
    inputBox.BorderSizePixel = 0  
    inputBox.Position = UDim2.new(0.5, -150, 0, 90)  
    inputBox.Size = UDim2.new(0, 300, 0, 40)  
    inputBox.Font = Enum.Font.Gotham  
    inputBox.PlaceholderText = "Enter key..."  
    inputBox.Text = ""  
    inputBox.TextColor3 = Color3.fromRGB(255, 255, 255)  
    inputBox.TextSize = 16  
    inputBox.ClearTextOnFocus = false  
    
    local inputCorner = Instance.new("UICorner")  
    inputCorner.CornerRadius = UDim.new(0, 8)  
    inputCorner.Parent = inputBox  
    
    local submitButton = Instance.new("TextButton")  
    submitButton.Name = "SubmitButton"  
    submitButton.Parent = mainFrame  
    submitButton.BackgroundColor3 = Color3.fromRGB(70, 130, 255)  
    submitButton.BorderSizePixel = 0  
    submitButton.Position = UDim2.new(0.5, -75, 0, 140)  
    submitButton.Size = UDim2.new(0, 150, 0, 40)  
    submitButton.Font = Enum.Font.GothamBold  
    submitButton.Text = "Submit"  
    submitButton.TextColor3 = Color3.fromRGB(255, 255, 255)  
    submitButton.TextSize = 16  
    
    local buttonCorner = Instance.new("UICorner")  
    buttonCorner.CornerRadius = UDim.new(0, 8)  
    buttonCorner.Parent = submitButton  
    
    local errorMsg = Instance.new("TextLabel")  
    errorMsg.Name = "ErrorMessage"  
    errorMsg.Parent = mainFrame  
    errorMsg.BackgroundTransparency = 1  
    errorMsg.Position = UDim2.new(0, 0, 0, 185)  
    errorMsg.Size = UDim2.new(1, 0, 0, 20)  
    errorMsg.Font = Enum.Font.Gotham  
    errorMsg.Text = ""  
    errorMsg.TextColor3 = Color3.fromRGB(255, 100, 100)  
    errorMsg.TextSize = 12  
    errorMsg.TextXAlignment = Enum.TextXAlignment.Center  
    errorMsg.Visible = false  
    
    local function submitKey()  
        if inputBox.Text == correctKey then  
            keyVerified = true  
            keyGui:Destroy()  
        else  
            errorMsg.Text = "Invalid key! Please try again."  
            errorMsg.Visible = true  
            inputBox.Text = ""  
            inputBox:CaptureFocus()  
        end  
    end  
    
    submitButton.MouseButton1Click:Connect(submitKey)  
    inputBox.FocusLost:Connect(function(enterPressed)  
        if enterPressed then  
            submitKey()  
        end  
    end)  
    
    inputBox:CaptureFocus()  
end

createKeyPrompt()

while not keyVerified do
    RunService.Heartbeat:Wait()
end

if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

if getgenv().bypassadonis then
    task.spawn(function()
        local getinfo = debug and (debug.getinfo or getinfo) or nil
        local flagged = false
        local hooks = {}
        local x, y
        setthreadidentity(2)
        for _, v in pairs(getgc(true)) do
            if typeof(v) == "table" then
                local detected = rawget(v, "Detected")
                local kill = rawget(v, "Kill")
                if typeof(detected) == "function" and not x then
                    x = detected
                    if hookfunction then
                        local original = hookfunction(x, function(...)
                            local c, f, n = ...
                            if c then
                                if flagged then
                                    warn("Adonis AntiCheat flagged", c, f)
                                end
                            end
                            return true
                        end)
                    end
                    table.insert(hooks, x)
                end
                if typeof(kill) == "function" and not y then
                    y = kill
                    if hookfunction then
                        local original = hookfunction(y, function(...)
                            if flagged then
                                warn("Adonis AntiCheat tried to kill fallback")
                            end
                        end)
                    end
                    table.insert(hooks, y)
                end
            end
        end
        setthreadidentity(7)
    end)
end

if not getgenv().DeXState then
    getgenv().DeXState = {
        isLockedOn = false,
        targetPlayer = nil,
        lockEnabled = false,
        aimLockEnabled = false,
        smoothingFactor = 0.1,
        predictionFactor = 0.0,
        bodyPartSelected = "Head",
        lockedTime = 12,
        antiLockEnabled = false,
        resolverIntensity = 1.0,
        resolverMethod = "Recalculate",
        reverseResolveIntensity = 5,
        Desync = false,
        DesyncEnabled = false,
        fovEnabled = false,
        fovValue = 130,
        SelfChamsEnabled = false,
        OtherChamsEnabled = false,
        RainbowChamsEnabled = false,
        SelfChamsColor = Color3.fromRGB(255, 255, 255),
        OtherChamsColor = Color3.fromRGB(255, 0, 0),
        nebulaEnabled = false,
        espEnabled = false,
        espNameTag = false,
        espBox = false,
        espTracer = false,
        espHeadDot = false,
        espHealthBar = false,
        espTeamCheck = false,
        isSpeedActive = false,
        isFlyActive = false,
        isNoClipActive = false,
        flySpeed = 50,
        strafeEnabled = false,
        strafeSpeed = 50,
        strafeRadius = 5,
        strafeMode = "Horizontal",
        silentAimEnabled = false,
        teamCheck = false,
        targetPart = "HumanoidRootPart",
        hitChance = 100,
        bulletTeleport = false,
        silentAimMethod = "Raycast",
        hitSoundEnabled = false,
        hitSoundId = "rbxassetid://6565370984",
        aimLockKeybind = Enum.KeyCode.Q,
        menuKeybind = Enum.KeyCode.End,
        flyKeybind = Enum.KeyCode.F,
        speedKeybind = Enum.KeyCode.X,
        noclipKeybind = Enum.KeyCode.N,
        strafeKeybind = Enum.KeyCode.C,
        masterToggle = true,
    }
end

local DeXState = getgenv().DeXState

local SilentAimSettings = {
    Enabled = false,
    ClassName = "DeX github.comFakeAngles",
    TeamCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = false,
    ShowSilentAimTarget = false,
    HitChance = 100,
    BulletTP = false
}
getgenv().SilentAimSettings = SilentAimSettings

local fovcircle = Drawing.new("Circle")
fovcircle.Thickness = 2
fovcircle.NumSides = 100
fovcircle.Radius = 130
fovcircle.Filled = false
fovcircle.Visible = false
fovcircle.ZIndex = 999
fovcircle.Transparency = 1
fovcircle.Color = Color3.fromRGB(70, 130, 255)

local sounds = {
    RIFK7 = "rbxassetid://9102080552",
    Bubble = "rbxassetid://9102092728",
    Minecraft = "rbxassetid://5869422451",
    Cod = "rbxassetid://160432334",
    Bameware = "rbxassetid://6565367558",
    Neverlose = "rbxassetid://6565370984",
    Gamesense = "rbxassetid://4817809188",
    Rust = "rbxassetid://6565371338",
}

local hitSound = Instance.new("Sound")
hitSound.Volume = 0.5
hitSound.SoundId = DeXState.hitSoundId
hitSound.Parent = SoundService

local soundPool = {}
local soundIndex = 1

local function getNextSound()
    if soundIndex > #soundPool then
        local s = hitSound:Clone()
        s.Parent = workspace
        s.Looped = false
        table.insert(soundPool, s)
    end
    local s = soundPool[soundIndex]
    soundIndex = soundIndex + 1
    if soundIndex > #soundPool then soundIndex = 1 end
    return s
end

local function playHitSound()
    if DeXState.hitSoundEnabled then
        local s = getNextSound()
        s:Stop()
        s:Play()
    end
end

local ESP = nil
local espObjects = {}
local chamsObjects = {}

-- Improved ESP system
local function createESP(player)
    if player == Players.LocalPlayer then return end
    if not player.Character then return end
    
    local char = player.Character
    if not char:FindFirstChild("HumanoidRootPart") then return end
    
    local espFolder = Instance.new("Folder")
    espFolder.Name = "ESP_" .. player.Name
    espFolder.Parent = CoreGui
    
    -- Box
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Color3.fromRGB(255, 255, 255)
    box.Thickness = 2
    box.Filled = false
    box.Transparency = 1
    
    -- Name
    local name = Drawing.new("Text")
    name.Visible = false
    name.Color = Color3.fromRGB(255, 255, 255)
    name.Size = 14
    name.Center = true
    name.Outline = true
    name.Font = 2
    
    -- Health bar
    local healthBarOutline = Drawing.new("Square")
    healthBarOutline.Visible = false
    healthBarOutline.Color = Color3.fromRGB(0, 0, 0)
    healthBarOutline.Thickness = 1
    healthBarOutline.Filled = true
    healthBarOutline.Transparency = 1
    
    local healthBar = Drawing.new("Square")
    healthBar.Visible = false
    healthBar.Color = Color3.fromRGB(0, 255, 0)
    healthBar.Thickness = 1
    healthBar.Filled = true
    healthBar.Transparency = 1
    
    -- Tracer
    local tracer = Drawing.new("Line")
    tracer.Visible = false
    tracer.Color = Color3.fromRGB(255, 255, 255)
    tracer.Thickness = 1
    tracer.Transparency = 1
    
    espObjects[player] = {
        box = box,
        name = name,
        healthBarOutline = healthBarOutline,
        healthBar = healthBar,
        tracer = tracer,
        player = player
    }
end

local function updateESP()
    for player, esp in pairs(espObjects) do
        if not player or not player.Parent or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
            if esp.box then esp.box.Visible = false end
            if esp.name then esp.name.Visible = false end
            if esp.healthBarOutline then esp.healthBarOutline.Visible = false end
            if esp.healthBar then esp.healthBar.Visible = false end
            if esp.tracer then esp.tracer.Visible = false end
            continue
        end
        
        local char = player.Character
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        
        if not hrp or not humanoid then continue end
        
        local shouldShow = DeXState.espEnabled and (not DeXState.espTeamCheck or player.Team ~= Players.LocalPlayer.Team)
        
        if not shouldShow then
            esp.box.Visible = false
            esp.name.Visible = false
            esp.healthBarOutline.Visible = false
            esp.healthBar.Visible = false
            esp.tracer.Visible = false
            continue
        end
        
        -- Get position on screen
        local position, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        
        if not onScreen then
            esp.box.Visible = false
            esp.name.Visible = false
            esp.healthBarOutline.Visible = false
            esp.healthBar.Visible = false
            esp.tracer.Visible = false
            continue
        end
        
        -- Calculate box size based on character size
        local size = Vector2.new(2000 / position.Z, 3000 / position.Z)
        local offset = Vector2.new(size.X / 2, size.Y / 2)
        
        -- Box
        if DeXState.espBox then
            esp.box.Visible = true
            esp.box.Size = size
            esp.box.Position = Vector2.new(position.X - offset.X, position.Y - offset.Y)
        else
            esp.box.Visible = false
        end
        
        -- Name
        if DeXState.espNameTag then
            esp.name.Visible = true
            esp.name.Text = player.Name
            esp.name.Position = Vector2.new(position.X, position.Y - offset.Y - 20)
        else
            esp.name.Visible = false
        end
        
        -- Health bar
        if DeXState.espHealthBar then
            local healthPercentage = humanoid.Health / humanoid.MaxHealth
            local barHeight = size.Y * healthPercentage
            local barWidth = 4
            
            esp.healthBarOutline.Visible = true
            esp.healthBarOutline.Size = Vector2.new(barWidth + 2, size.Y + 2)
            esp.healthBarOutline.Position = Vector2.new(position.X - offset.X - barWidth - 5, position.Y - offset.Y - 1)
            
            esp.healthBar.Visible = true
            esp.healthBar.Size = Vector2.new(barWidth, barHeight)
            esp.healthBar.Position = Vector2.new(position.X - offset.X - barWidth - 4, position.Y - offset.Y + (size.Y - barHeight))
            
            -- Change color based on health
            if healthPercentage > 0.5 then
                esp.healthBar.Color = Color3.fromRGB(0, 255, 0)
            elseif healthPercentage > 0.25 then
                esp.healthBar.Color = Color3.fromRGB(255, 255, 0)
            else
                esp.healthBar.Color = Color3.fromRGB(255, 0, 0)
            end
        else
            esp.healthBarOutline.Visible = false
            esp.healthBar.Visible = false
        end
        
        -- Tracer
        if DeXState.espTracer then
            esp.tracer.Visible = true
            esp.tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
            esp.tracer.To = Vector2.new(position.X, position.Y + offset.Y)
        else
            esp.tracer.Visible = false
        end
    end
end

local function clearESP()
    for player, esp in pairs(espObjects) do
        if esp.box then esp.box:Remove() end
        if esp.name then esp.name:Remove() end
        if esp.healthBarOutline then esp.healthBarOutline:Remove() end
        if esp.healthBar then esp.healthBar:Remove() end
        if esp.tracer then esp.tracer:Remove() end
    end
    espObjects = {}
end

-- Improved chams system
local function applyChams(char, isSelf)
    if not char then return end
    
    local chamsFolder = Instance.new("Folder")
    chamsFolder.Name = "Chams_" .. char.Name
    chamsFolder.Parent = CoreGui
    
    local parts = {}
    
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            local highlight = Instance.new("Highlight")
            highlight.Parent = chamsFolder
            highlight.Adornee = part
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlight.FillTransparency = 0.5
            highlight.OutlineTransparency = 0
            
            if isSelf then
                highlight.FillColor = DeXState.SelfChamsColor
                highlight.OutlineColor = DeXState.SelfChamsColor
            else
                highlight.FillColor = DeXState.OtherChamsColor
                highlight.OutlineColor = DeXState.OtherChamsColor
            end
            
            parts[part] = highlight
        end
    end
    
    chamsObjects[char] = {
        folder = chamsFolder,
        parts = parts
    }
end

local function removeChams(char)
    if chamsObjects[char] then
        chamsObjects[char].folder:Destroy()
        chamsObjects[char] = nil
    end
end

local function updateChams()
    if DeXState.RainbowChamsEnabled then
        local hue = (tick() * 100) % 360
        local rainbowColor = Color3.fromHSV(hue/360, 1, 1)
        
        for char, chamsData in pairs(chamsObjects) do
            for part, highlight in pairs(chamsData.parts) do
                if part and part.Parent then
                    highlight.FillColor = rainbowColor
                    highlight.OutlineColor = rainbowColor
                end
            end
        end
    else
        for char, chamsData in pairs(chamsObjects) do
            for part, highlight in pairs(chamsData.parts) do
                if part and part.Parent then
                    if char == Players.LocalPlayer.Character then
                        highlight.FillColor = DeXState.SelfChamsColor
                        highlight.OutlineColor = DeXState.SelfChamsColor
                    else
                        highlight.FillColor = DeXState.OtherChamsColor
                        highlight.OutlineColor = DeXState.OtherChamsColor
                    end
                end
            end
        end
    end
end

local function clearAllChams()
    for char, chamsData in pairs(chamsObjects) do
        chamsData.folder:Destroy()
    end
    chamsObjects = {}
end

-- Improved walkspeed method
local Players = game:GetService("Players")

local walkSpeedConn -- store the connection

local function setWalkSpeed(speed)
    local char = Players.LocalPlayer.Character
    if not char then return end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    if not getgenv().originalWalkSpeed then
        getgenv().originalWalkSpeed = humanoid.WalkSpeed
    end

    -- enforce while active
    if DeXState.isSpeedActive then
        humanoid.WalkSpeed = speed

        -- clean up old connection before making a new one
        if walkSpeedConn then
            walkSpeedConn:Disconnect()
            walkSpeedConn = nil
        end

        walkSpeedConn = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if DeXState.isSpeedActive and humanoid.WalkSpeed ~= speed then
                humanoid.WalkSpeed = speed
            end
        end)
    else
        humanoid.WalkSpeed = getgenv().originalWalkSpeed or 16

        -- disconnect if not active anymore
        if walkSpeedConn then
            walkSpeedConn:Disconnect()
            walkSpeedConn = nil
        end
    end
end

-- Improved fly system
local flyBodyVelocity = nil
local flyBodyGyro = nil
local connections = {}
local keybindConnections = {}

local keysPressed = {}

local function getBodyPart(character, partName)
    return character:FindFirstChild(partName) or character:FindFirstChild("Head")
end

local function getNearestPlayerToMouse()
    if not DeXState.aimLockEnabled or not DeXState.masterToggle then return nil end
    local nearestPlayer = nil
    local shortestDistance = math.huge
    local mousePosition = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild(DeXState.bodyPartSelected) then  
            if DeXState.teamCheck and player.Team == Players.LocalPlayer.Team then continue end  
              
            local part = player.Character[DeXState.bodyPartSelected]  
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)  
            if onScreen then  
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePosition).Magnitude  
                if distance < shortestDistance then  
                    nearestPlayer = player  
                    shortestDistance = distance  
                end  
            end  
        end  
    end  
    return nearestPlayer  
end

local function toggleLockOnPlayer()
    if not DeXState.lockEnabled or not DeXState.aimLockEnabled or not DeXState.masterToggle then return end

    if DeXState.isLockedOn then  
        DeXState.isLockedOn = false  
        DeXState.targetPlayer = nil  
    else  
        DeXState.targetPlayer = getNearestPlayerToMouse()  
        if DeXState.targetPlayer and DeXState.targetPlayer.Character then  
            local part = getBodyPart(DeXState.targetPlayer.Character, DeXState.bodyPartSelected)  
            if part then  
                DeXState.isLockedOn = true  
            end  
        end  
    end  
end

local function CalculateChancePercentage(percentage)
    local chance = math.floor(math.random() * 100) + 1
    return chance <= percentage
end

local function getClosestPlayerForSilentAim()
    local closest = nil
    local shortestDistance = SilentAimSettings.FOVRadius or 130
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do  
        if player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild(SilentAimSettings.TargetPart) then  
            if SilentAimSettings.TeamCheck and player.Team == Players.LocalPlayer.Team then  
                continue  
            end  
            local part = player.Character[SilentAimSettings.TargetPart]  
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)  
            if onScreen then  
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - center).Magnitude  
                if distance < shortestDistance then  
                    closest = part  
                    shortestDistance = distance  
                end  
            end  
        end  
    end  
    return closest  
end

local function HSVToRGB(h, s, v)
    local c = v * s
    local x = c * (1 - math.abs((h / 60) % 2 - 1))
    local m = v - c
    local r, g, b = 0, 0, 0

    if h < 60 then r, g, b = c, x, 0  
    elseif h < 120 then r, g, b = x, c, 0  
    elseif h < 180 then r, g, b = 0, c, x  
    elseif h < 240 then r, g, b = 0, x, c  
    elseif h < 300 then r, g, b = x, 0, c  
    else r, g, b = c, 0, x  
    end  
    return Color3.new(r + m, g + m, b + m)  
end

local function handleFly()
    if not DeXState.isFlyActive or not Players.LocalPlayer.Character or not DeXState.masterToggle then 
        if flyBodyVelocity then
            flyBodyVelocity:Destroy()
            flyBodyVelocity = nil
        end
        if flyBodyGyro then
            flyBodyGyro:Destroy()
            flyBodyGyro = nil
        end
        return 
    end
    
    local character = Players.LocalPlayer.Character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    -- Create fly objects if they don't exist
    if not flyBodyVelocity then
        flyBodyVelocity = Instance.new("BodyVelocity")
        flyBodyVelocity.MaxForce = Vector3.new(10000, 10000, 10000)
        flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
        flyBodyVelocity.Parent = humanoidRootPart
    end
    
    if not flyBodyGyro then
        flyBodyGyro = Instance.new("BodyGyro")
        flyBodyGyro.MaxTorque = Vector3.new(10000, 10000, 10000)
        flyBodyGyro.P = 1000
        flyBodyGyro.D = 50
        flyBodyGyro.CFrame = humanoidRootPart.CFrame
        flyBodyGyro.Parent = humanoidRootPart
    end
    
    -- Update fly controls
    local flyDirection = Vector3.new(0, 0, 0)
    
    if keysPressed[Enum.KeyCode.W] then
        flyDirection = flyDirection + (Camera.CFrame.LookVector * DeXState.flySpeed)
    end
    if keysPressed[Enum.KeyCode.S] then
        flyDirection = flyDirection - (Camera.CFrame.LookVector * DeXState.flySpeed)
    end
    if keysPressed[Enum.KeyCode.A] then
        flyDirection = flyDirection - (Camera.CFrame.RightVector * DeXState.flySpeed)
    end
    if keysPressed[Enum.KeyCode.D] then
        flyDirection = flyDirection + (Camera.CFrame.RightVector * DeXState.flySpeed)
    end
    if keysPressed[Enum.KeyCode.Space] then
        flyDirection = flyDirection + (Vector3.new(0, 1, 0) * DeXState.flySpeed)
    end
    if keysPressed[Enum.KeyCode.LeftControl] or keysPressed[Enum.KeyCode.LeftShift] then
        flyDirection = flyDirection - (Vector3.new(0, 1, 0) * DeXState.flySpeed)
    end
    
    -- Apply fly velocity
    if flyBodyVelocity then
        flyBodyVelocity.Velocity = flyDirection
    end
    
    -- Keep gyro aligned with camera
    if flyBodyGyro then
        flyBodyGyro.CFrame = CFrame.new(humanoidRootPart.Position, humanoidRootPart.Position + Camera.CFrame.LookVector)
    end
end

local function handleMovement()
    if not DeXState.masterToggle then return end

    -- Handle walkspeed
    if DeXState.isSpeedActive then
        setWalkSpeed(DeXState.flySpeed)
    else
        setWalkSpeed(getgenv().originalWalkSpeed or 16)
    end
    
    -- Handle noclip
    if DeXState.isNoClipActive and Players.LocalPlayer.Character then
        for _, part in pairs(Players.LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = false
            end
        end
    end
    
    -- Handle fly
    handleFly()
end

local function handleStrafe()
    if not DeXState.strafeEnabled or not DeXState.targetPlayer or not DeXState.masterToggle then return end

    local char = Players.LocalPlayer.Character  
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end  
    
    local hrp = char.HumanoidRootPart  
    local targetHrp = DeXState.targetPlayer.Character and DeXState.targetPlayer.Character:FindFirstChild("HumanoidRootPart")  
    if not targetHrp then return end  
    
    local angle = tick() * (DeXState.strafeSpeed / 10)  
    local radius = DeXState.strafeRadius  
    
    local offsetX = math.cos(angle) * radius  
    local offsetZ = math.sin(angle) * radius  
    
    local targetPos = targetHrp.Position + Vector3.new(offsetX, 0, offsetZ)  
    local direction = (targetPos - hrp.Position).Unit  
    
    hrp.Velocity = Vector3.new(direction.X * DeXState.strafeSpeed, hrp.Velocity.Y, direction.Z * DeXState.strafeSpeed)  
end

local function setupKeybinds()
    for _, connection in pairs(keybindConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    keybindConnections = {}

    keybindConnections[#keybindConnections + 1] = UserInputService.InputBegan:Connect(function(input, gameProcessed)  
        if gameProcessed then return end  
          
        keysPressed[input.KeyCode] = true  
          
        if input.KeyCode == DeXState.aimLockKeybind then  
            toggleLockOnPlayer()  
        end  
          
        if input.KeyCode == DeXState.speedKeybind then  
            DeXState.isSpeedActive = not DeXState.isSpeedActive
            setWalkSpeed(DeXState.isSpeedActive and DeXState.flySpeed or (getgenv().originalWalkSpeed or 16))
        end  
          
        if input.KeyCode == DeXState.flyKeybind then  
            DeXState.isFlyActive = not DeXState.isFlyActive
            if not DeXState.isFlyActive then
                if flyBodyVelocity then
                    flyBodyVelocity:Destroy()
                    flyBodyVelocity = nil
                end
                if flyBodyGyro then
                    flyBodyGyro:Destroy()
                    flyBodyGyro = nil
                end
            end
        end  
          
        if input.KeyCode == DeXState.noclipKeybind then  
            DeXState.isNoClipActive = not DeXState.isNoClipActive  
        end  
          
        if input.KeyCode == DeXState.strafeKeybind then  
            DeXState.strafeEnabled = not DeXState.strafeEnabled  
        end  
    end)  
    
    keybindConnections[#keybindConnections + 1] = UserInputService.InputEnded:Connect(function(input, gameProcessed)  
        keysPressed[input.KeyCode] = false  
    end)  
end

local function createUI()
    if CoreGui:FindFirstChild("DeXModernUI") then
        CoreGui:FindFirstChild("DeXModernUI"):Destroy()
    end

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "DeXModernUI"
    ScreenGui.Parent = CoreGui
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    MainFrame.BorderSizePixel = 0
    MainFrame.Position = UDim2.new(0.5, -400, 0.5, -350)
    MainFrame.Size = UDim2.new(0, 800, 0, 700)
    MainFrame.ClipsDescendants = true

    local MainCorner = Instance.new("UICorner")
    MainCorner.CornerRadius = UDim.new(0, 12)
    MainCorner.Parent = MainFrame

    local Gradient = Instance.new("UIGradient")
    Gradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 20))
    }
    Gradient.Rotation = 45
    Gradient.Parent = MainFrame

    local TitleBar = Instance.new("Frame")
    TitleBar.Name = "TitleBar"
    TitleBar.Parent = MainFrame
    TitleBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    TitleBar.BorderSizePixel = 0
    TitleBar.Size = UDim2.new(1, 0, 0, 40)

    local TitleCorner = Instance.new("UICorner")
    TitleCorner.CornerRadius = UDim.new(0, 12)
    TitleCorner.Parent = TitleBar

    local Title = Instance.new("TextLabel")
    Title.Name = "Title"
    Title.Parent = TitleBar
    Title.BackgroundTransparency = 1
    Title.Position = UDim2.new(0, 15, 0, 0)
    Title.Size = UDim2.new(1, -60, 1, 0)
    Title.Font = Enum.Font.GothamBold
    Title.Text = "DeX DaHood - Version 0.0.1"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.TextSize = 18
    Title.TextXAlignment = Enum.TextXAlignment.Left

    local CloseButton = Instance.new("TextButton")
    CloseButton.Name = "CloseButton"
    CloseButton.Parent = TitleBar
    CloseButton.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
    CloseButton.BorderSizePixel = 0
    CloseButton.Position = UDim2.new(1, -35, 0, 5)
    CloseButton.Size = UDim2.new(0, 30, 0, 30)
    CloseButton.Font = Enum.Font.GothamBold
    CloseButton.Text = "Ã—"
    CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseButton.TextSize = 18

    local CloseCorner = Instance.new("UICorner")
    CloseCorner.CornerRadius = UDim.new(0, 8)
    CloseCorner.Parent = CloseButton

    local TabContainer = Instance.new("Frame")
    TabContainer.Name = "TabContainer"
    TabContainer.Parent = MainFrame
    TabContainer.BackgroundTransparency = 1
    TabContainer.Position = UDim2.new(0, 0, 0, 40)
    TabContainer.Size = UDim2.new(1, 0, 0, 50)

    local ContentContainer = Instance.new("Frame")
    ContentContainer.Name = "ContentContainer"
    ContentContainer.Parent = MainFrame
    ContentContainer.BackgroundTransparency = 1
    ContentContainer.Position = UDim2.new(0, 10, 0, 90)
    ContentContainer.Size = UDim2.new(1, -20, 1, -100)
    ContentContainer.ClipsDescendants = true

    local tabs = {}
    local currentTab = nil

    local function createTab(name, isDefault)
        local TabButton = Instance.new("TextButton")
        TabButton.Name = name .. "Tab"
        TabButton.Parent = TabContainer
        TabButton.BackgroundColor3 = isDefault and Color3.fromRGB(70, 130, 255) or Color3.fromRGB(50, 50, 50)
        TabButton.BorderSizePixel = 0
        TabButton.Size = UDim2.new(0, 120, 0, 35)
        TabButton.Font = Enum.Font.Gotham
        TabButton.Text = name
        TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        TabButton.TextSize = 14

        local TabCorner = Instance.new("UICorner")
        TabCorner.CornerRadius = UDim.new(0, 8)
        TabCorner.Parent = TabButton

        local TabContent = Instance.new("ScrollingFrame")
        TabContent.Name = name .. "Content"
        TabContent.Parent = ContentContainer
        TabContent.BackgroundTransparency = 1
        TabContent.Size = UDim2.new(1, 0, 1, 0)
        TabContent.ScrollBarThickness = 6
        TabContent.ScrollBarImageColor3 = Color3.fromRGB(70, 130, 255)
        TabContent.Visible = isDefault or false
        TabContent.CanvasSize = UDim2.new(0, 0, 0, 0)
        TabContent.AutomaticCanvasSize = Enum.AutomaticSize.Y

        local UIListLayout = Instance.new("UIListLayout")
        UIListLayout.Parent = TabContent
        UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        UIListLayout.Padding = UDim.new(0, 5)

        tabs[name] = {
            button = TabButton,
            content = TabContent
        }

        if isDefault then
            currentTab = name
        end

        TabButton.MouseButton1Click:Connect(function()
            for tabName, tab in pairs(tabs) do
                local isActive = tabName == name
                tab.content.Visible = isActive
                tab.button.BackgroundColor3 = isActive and Color3.fromRGB(70, 130, 255) or Color3.fromRGB(50, 50, 50)
            end
            currentTab = name
        end)

        return TabContent
    end

    -- Create tabs first
    local AimTab = createTab("Aim", true)
    local VisualsTab = createTab("Visuals", false)
    local MovementTab = createTab("Movement", false)
    local SettingsTab = createTab("Settings", false)
    local KeybindsTab = createTab("Keybinds", false)
    
    -- Position tabs after creating them
    local tabIndex = 0
    for tabName, tab in pairs(tabs) do
        tab.button.Position = UDim2.new(0, 10 + (tabIndex * 130), 0, 7.5)
        tabIndex = tabIndex + 1
    end

    local yOffset = 0

    local function createToggle(parent, text, default, callback)
        local ToggleFrame = Instance.new("Frame")
        ToggleFrame.Name = text .. "Toggle"
        ToggleFrame.Parent = parent
        ToggleFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        ToggleFrame.BorderSizePixel = 0
        ToggleFrame.Size = UDim2.new(1, -20, 0, 40)
        ToggleFrame.LayoutOrder = yOffset

        local ToggleCorner = Instance.new("UICorner")
        ToggleCorner.CornerRadius = UDim.new(0, 8)
        ToggleCorner.Parent = ToggleFrame

        local ToggleLabel = Instance.new("TextLabel")
        ToggleLabel.Parent = ToggleFrame
        ToggleLabel.BackgroundTransparency = 1
        ToggleLabel.Position = UDim2.new(0, 15, 0, 0)
        ToggleLabel.Size = UDim2.new(1, -60, 1, 0)
        ToggleLabel.Font = Enum.Font.Gotham
        ToggleLabel.Text = text
        ToggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        ToggleLabel.TextSize = 14
        ToggleLabel.TextXAlignment = Enum.TextXAlignment.Left

        local ToggleButton = Instance.new("TextButton")
        ToggleButton.Parent = ToggleFrame
        ToggleButton.BackgroundColor3 = default and Color3.fromRGB(70, 130, 255) or Color3.fromRGB(60, 60, 60)
        ToggleButton.BorderSizePixel = 0
        ToggleButton.Position = UDim2.new(1, -40, 0, 10)
        ToggleButton.Size = UDim2.new(0, 30, 0, 20)
        ToggleButton.Text = ""

        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 10)
        ButtonCorner.Parent = ToggleButton

        local isEnabled = default

        ToggleButton.MouseButton1Click:Connect(function()
            isEnabled = not isEnabled
            ToggleButton.BackgroundColor3 = isEnabled and Color3.fromRGB(70, 130, 255) or Color3.fromRGB(60, 60, 60)
            if callback then callback(isEnabled) end
        end)

        yOffset = yOffset + 1
        return {
            frame = ToggleFrame, 
            getValue = function() return isEnabled end, 
            setValue = function(val) 
                isEnabled = val
                ToggleButton.BackgroundColor3 = isEnabled and Color3.fromRGB(70, 130, 255) or Color3.fromRGB(60, 60, 60)
            end
        }
    end

    local function createSlider(parent, text, min, max, default, callback)
        local SliderFrame = Instance.new("Frame")
        SliderFrame.Name = text .. "Slider"
        SliderFrame.Parent = parent
        SliderFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        SliderFrame.BorderSizePixel = 0
        SliderFrame.Size = UDim2.new(1, -20, 0, 60)
        SliderFrame.LayoutOrder = yOffset

        local SliderCorner = Instance.new("UICorner")
        SliderCorner.CornerRadius = UDim.new(0, 8)
        SliderCorner.Parent = SliderFrame

        local SliderLabel = Instance.new("TextLabel")
        SliderLabel.Parent = SliderFrame
        SliderLabel.BackgroundTransparency = 1
        SliderLabel.Position = UDim2.new(0, 15, 0, 5)
        SliderLabel.Size = UDim2.new(1, -30, 0, 20)
        SliderLabel.Font = Enum.Font.Gotham
        SliderLabel.Text = text .. ": " .. tostring(default)
        SliderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        SliderLabel.TextSize = 14
        SliderLabel.TextXAlignment = Enum.TextXAlignment.Left

        local SliderBar = Instance.new("Frame")
        SliderBar.Parent = SliderFrame
        SliderBar.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        SliderBar.BorderSizePixel = 0
        SliderBar.Position = UDim2.new(0, 15, 0, 35)
        SliderBar.Size = UDim2.new(1, -30, 0, 6)

        local BarCorner = Instance.new("UICorner")
        BarCorner.CornerRadius = UDim.new(0, 3)
        BarCorner.Parent = SliderBar

        local SliderFill = Instance.new("Frame")
        SliderFill.Parent = SliderBar
        SliderFill.BackgroundColor3 = Color3.fromRGB(70, 130, 255)
        SliderFill.BorderSizePixel = 0
        SliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)

        local FillCorner = Instance.new("UICorner")
        FillCorner.CornerRadius = UDim.new(0, 3)
        FillCorner.Parent = SliderFill

        local SliderButton = Instance.new("TextButton")
        SliderButton.Parent = SliderBar
        SliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        SliderButton.BorderSizePixel = 0
        SliderButton.Position = UDim2.new((default - min) / (max - min), -8, 0, -6)
        SliderButton.Size = UDim2.new(0, 16, 0, 18)
        SliderButton.Text = ""

        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 8)
        ButtonCorner.Parent = SliderButton

        local currentValue = default
        local dragging = false

        local function updateSlider()
            SliderLabel.Text = text .. ": " .. tostring(math.floor(currentValue * 100) / 100)
            local percentage = (currentValue - min) / (max - min)
            SliderFill.Size = UDim2.new(percentage, 0, 1, 0)
            SliderButton.Position = UDim2.new(percentage, -8, 0, -6)
            if callback then callback(currentValue) end
        end

        SliderButton.MouseButton1Down:Connect(function()
            dragging = true
        end)

        local connection
        connection = UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)

        local connection2
        connection2 = UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local mousePos = UserInputService:GetMouseLocation()
                local sliderPos = SliderBar.AbsolutePosition.X
                local sliderSize = SliderBar.AbsoluteSize.X
                local percentage = math.clamp((mousePos.X - sliderPos) / sliderSize, 0, 1)
                currentValue = min + (percentage * (max - min))
                updateSlider()
            end
        end)

        yOffset = yOffset + 1
        return {
            frame = SliderFrame, 
            getValue = function() return currentValue end,
            destroy = function()
                if connection then connection:Disconnect() end
                if connection2 then connection2:Disconnect() end
            end
        }
    end

    local function createDropdown(parent, text, options, default, callback)
        local DropdownFrame = Instance.new("Frame")
        DropdownFrame.Name = text .. "Dropdown"
        DropdownFrame.Parent = parent
        DropdownFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        DropdownFrame.BorderSizePixel = 0
        DropdownFrame.Size = UDim2.new(1, -20, 0, 40)
        DropdownFrame.LayoutOrder = yOffset
        DropdownFrame.ClipsDescendants = true

        local DropdownCorner = Instance.new("UICorner")
        DropdownCorner.CornerRadius = UDim.new(0, 8)
        DropdownCorner.Parent = DropdownFrame

        local DropdownButton = Instance.new("TextButton")
        DropdownButton.Parent = DropdownFrame
        DropdownButton.BackgroundTransparency = 1
        DropdownButton.Size = UDim2.new(1, 0, 1, 0)
        DropdownButton.Font = Enum.Font.Gotham
        DropdownButton.Text = text .. ": " .. (default or options[1] or "None")
        DropdownButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        DropdownButton.TextSize = 14

        local currentValue = default or options[1]
        local isOpen = false

        DropdownButton.MouseButton1Click:Connect(function()
            isOpen = not isOpen
            if isOpen then
                DropdownFrame.Size = UDim2.new(1, -20, 0, 40 + (#options * 30))
                for i, option in ipairs(options) do
                    local OptionButton = Instance.new("TextButton")
                    OptionButton.Name = "Option" .. i
                    OptionButton.Parent = DropdownFrame
                    OptionButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
                    OptionButton.BorderSizePixel = 0
                    OptionButton.Position = UDim2.new(0, 0, 0, 40 + ((i-1) * 30))
                    OptionButton.Size = UDim2.new(1, 0, 0, 30)
                    OptionButton.Font = Enum.Font.Gotham
                    OptionButton.Text = option
                    OptionButton.TextColor3 = Color3.fromRGB(200, 200, 200)
                    OptionButton.TextSize = 12
                    
                    OptionButton.MouseButton1Click:Connect(function()
                        currentValue = option
                        DropdownButton.Text = text .. ": " .. option
                        if callback then callback(option) end
                        
                        for j = 1, #options do
                            local opt = DropdownFrame:FindFirstChild("Option" .. j)
                            if opt then opt:Destroy() end
                        end
                        DropdownFrame.Size = UDim2.new(1, -20, 0, 40)
                        isOpen = false
                    end)
                end
            else
                for j = 1, #options do
                    local opt = DropdownFrame:FindFirstChild("Option" .. j)
                    if opt then opt:Destroy() end
                end
                DropdownFrame.Size = UDim2.new(1, -20, 0, 40)
            end
        end)

        yOffset = yOffset + 1
        return {
            frame = DropdownFrame, 
            getValue = function() return currentValue end
        }
    end

    local function createKeybind(parent, text, default, callback)
        local KeybindFrame = Instance.new("Frame")
        KeybindFrame.Name = text .. "Keybind"
        KeybindFrame.Parent = parent
        KeybindFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        KeybindFrame.BorderSizePixel = 0
        KeybindFrame.Size = UDim2.new(1, -20, 0, 40)
        KeybindFrame.LayoutOrder = yOffset

        local KeybindCorner = Instance.new("UICorner")
        KeybindCorner.CornerRadius = UDim.new(0, 8)
        KeybindCorner.Parent = KeybindFrame

        local KeybindLabel = Instance.new("TextLabel")
        KeybindLabel.Parent = KeybindFrame
        KeybindLabel.BackgroundTransparency = 1
        KeybindLabel.Position = UDim2.new(0, 15, 0, 0)
        KeybindLabel.Size = UDim2.new(1, -120, 1, 0)
        KeybindLabel.Font = Enum.Font.Gotham
        KeybindLabel.Text = text
        KeybindLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        KeybindLabel.TextSize = 14
        KeybindLabel.TextXAlignment = Enum.TextXAlignment.Left

        local KeybindButton = Instance.new("TextButton")
        KeybindButton.Parent = KeybindFrame
        KeybindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        KeybindButton.BorderSizePixel = 0
        KeybindButton.Position = UDim2.new(1, -100, 0, 5)
        KeybindButton.Size = UDim2.new(0, 90, 0, 30)
        KeybindButton.Font = Enum.Font.Gotham
        KeybindButton.Text = default.Name
        KeybindButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        KeybindButton.TextSize = 12

        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 6)
        ButtonCorner.Parent = KeybindButton

        local currentKey = default
        local isBinding = false

        KeybindButton.MouseButton1Click:Connect(function()
            if isBinding then return end
            isBinding = true
            KeybindButton.Text = "Press Key..."
            KeybindButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
            
            local connection
            connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if input.UserInputType == Enum.UserInputType.Keyboard then
                    currentKey = input.KeyCode
                    KeybindButton.Text = input.KeyCode.Name
                    KeybindButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
                    isBinding = false
                    connection:Disconnect()
                    if callback then callback(currentKey) end
                end
            end)
        end)

        yOffset = yOffset + 1
        return {
            frame = KeybindFrame, 
            getValue = function() return currentKey end
        }
    end

    local function createColorPicker(parent, text, default, callback)
        local ColorFrame = Instance.new("Frame")
        ColorFrame.Name = text .. "ColorPicker"
        ColorFrame.Parent = parent
        ColorFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        ColorFrame.BorderSizePixel = 0
        ColorFrame.Size = UDim2.new(1, -20, 0, 40)
        ColorFrame.LayoutOrder = yOffset

        local ColorCorner = Instance.new("UICorner")
        ColorCorner.CornerRadius = UDim.new(0, 8)
        ColorCorner.Parent = ColorFrame

        local ColorLabel = Instance.new("TextLabel")
        ColorLabel.Parent = ColorFrame
        ColorLabel.BackgroundTransparency = 1
        ColorLabel.Position = UDim2.new(0, 15, 0, 0)
        ColorLabel.Size = UDim2.new(1, -60, 1, 0)
        ColorLabel.Font = Enum.Font.Gotham
        ColorLabel.Text = text
        ColorLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        ColorLabel.TextSize = 14
        ColorLabel.TextXAlignment = Enum.TextXAlignment.Left

        local ColorButton = Instance.new("TextButton")
        ColorButton.Parent = ColorFrame
        ColorButton.BackgroundColor3 = default
        ColorButton.BorderSizePixel = 0
        ColorButton.Position = UDim2.new(1, -40, 0, 10)
        ColorButton.Size = UDim2.new(0, 30, 0, 20)
        ColorButton.Text = ""

        local ButtonCorner = Instance.new("UICorner")
        ButtonCorner.CornerRadius = UDim.new(0, 4)
        ButtonCorner.Parent = ColorButton

        local currentColor = default

        ColorButton.MouseButton1Click:Connect(function()
            local colors = {
                Color3.fromRGB(255, 255, 255),
                Color3.fromRGB(255, 0, 0),
                Color3.fromRGB(0, 255, 0),
                Color3.fromRGB(0, 0, 255),
                Color3.fromRGB(255, 255, 0),
                Color3.fromRGB(255, 0, 255),
                Color3.fromRGB(0, 255, 255)
            }
            
            for i, color in ipairs(colors) do
                if currentColor == color then
                    currentColor = colors[i + 1] or colors[1]
                    break
                elseif i == #colors then
                    currentColor = colors[1]
                end
            end
            
            ColorButton.BackgroundColor3 = currentColor
            if callback then callback(currentColor) end
        end)

        yOffset = yOffset + 1
        return {
            frame = ColorFrame, 
            getValue = function() return currentColor end
        }
    end

    -- Reset yOffset for each tab
    yOffset = 0
    
    -- Aim Tab
    createToggle(AimTab, "Master Toggle", true, function(val)
        DeXState.masterToggle = val
    end)
    
    createToggle(AimTab, "Enable AimLock", false, function(val)
        DeXState.aimLockEnabled = val
        if not val then
            DeXState.lockEnabled = false
            DeXState.isLockedOn = false
            DeXState.targetPlayer = nil
        end
    end)
    
    createToggle(AimTab, "AimLock Keybind", false, function(val)
        DeXState.lockEnabled = val
        if not val then
            DeXState.isLockedOn = false
            DeXState.targetPlayer = nil
        end
    end)
    
    createSlider(AimTab, "Camera Smoothing", 0, 1, 0.1, function(val)
        DeXState.smoothingFactor = val
    end)
    
    createSlider(AimTab, "Prediction Factor", 0, 2, 0.0, function(val)
        DeXState.predictionFactor = val
    end)
    
    createSlider(AimTab, "Locked Time", 1, 30, 12, function(val)
        DeXState.lockedTime = val
    end)
    
    createDropdown(AimTab, "Target Body Part", {"Head", "UpperTorso", "RightUpperArm", "LeftUpperLeg", "RightUpperLeg", "LeftUpperArm"}, "Head", function(val)
        DeXState.bodyPartSelected = val
    end)
    
    createToggle(AimTab, "Anti-Lock", false, function(val)
        DeXState.antiLockEnabled = val
    end)
    
    createSlider(AimTab, "Resolver Intensity", 0.1, 3.0, 1.0, function(val)
        DeXState.resolverIntensity = val
    end)
    
    createSlider(AimTab, "Reverse Resolve Intensity", 1, 10, 5, function(val)
        DeXState.reverseResolveIntensity = val
    end)
    
    createDropdown(AimTab, "Resolver Method", {"Recalculate", "Randomize", "Invert"}, "Recalculate", function(val)
        DeXState.resolverMethod = val
    end)
    
    createToggle(AimTab, "Desync", false, function(val)
        DeXState.Desync = val
    end)
    
    createToggle(AimTab, "Desync Enabled", false, function(val)
        DeXState.DesyncEnabled = val
    end)
    
    createToggle(AimTab, "Silent Aim", false, function(val)
        DeXState.silentAimEnabled = val
        SilentAimSettings.Enabled = val
    end)
    
    createToggle(AimTab, "Team Check", false, function(val)
        DeXState.teamCheck = val
        SilentAimSettings.TeamCheck = val
    end)
    
    createToggle(AimTab, "Bullet Teleport", false, function(val)
        DeXState.bulletTeleport = val
        SilentAimSettings.BulletTP = val
    end)
    
    createDropdown(AimTab, "Silent Target Part", {"Head", "HumanoidRootPart", "UpperTorso"}, "HumanoidRootPart", function(val)
        DeXState.targetPart = val
        SilentAimSettings.TargetPart = val
    end)
    
    createDropdown(AimTab, "Silent Aim Method", {"Raycast", "FindPartOnRay", "ViewportPointToRay", "ScreenPointToRay"}, "Raycast", function(val)
        DeXState.silentAimMethod = val
        SilentAimSettings.SilentAimMethod = val
    end)
    
    createSlider(AimTab, "Hit Chance %", 0, 100, 100, function(val)
        DeXState.hitChance = val
        SilentAimSettings.HitChance = val
    end)
    
    -- Visuals Tab
    yOffset = 0
    createToggle(VisualsTab, "Show FOV Circle", false, function(val)
        DeXState.fovEnabled = val
        fovcircle.Visible = val
        SilentAimSettings.FOVVisible = val
    end)
    
    createSlider(VisualsTab, "FOV Circle Radius", 0, 360, 130, function(val)
        DeXState.fovValue = val
        fovcircle.Radius = val
        SilentAimSettings.FOVRadius = val
    end)
    
    createToggle(VisualsTab, "Enable ESP", false, function(val)
        DeXState.espEnabled = val
        if not val then
            clearESP()
        else
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer then
                    createESP(player)
                end
            end
        end
    end)
    
    createToggle(VisualsTab, "ESP Team Check", false, function(val)
        DeXState.espTeamCheck = val
    end)
    
    createToggle(VisualsTab, "ESP Name Tag", false, function(val)
        DeXState.espNameTag = val
    end)
    
    createToggle(VisualsTab, "ESP Box", false, function(val)
        DeXState.espBox = val
    end)
    
    createToggle(VisualsTab, "ESP Health Bar", false, function(val)
        DeXState.espHealthBar = val
    end)
    
    createToggle(VisualsTab, "ESP Tracer", false, function(val)
        DeXState.espTracer = val
    end)
    
    createToggle(VisualsTab, "Self Chams", false, function(val)
        DeXState.SelfChamsEnabled = val
        if val then
            if Players.LocalPlayer.Character then
                applyChams(Players.LocalPlayer.Character, true)
            end
        else
            removeChams(Players.LocalPlayer.Character)
        end
    end)
    
    createToggle(VisualsTab, "Other Player Chams", false, function(val)
        DeXState.OtherChamsEnabled = val
        if val then
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    applyChams(player.Character, false)
                end
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    removeChams(player.Character)
                end
            end
        end
    end)
    
    createToggle(VisualsTab, "Rainbow Chams", false, function(val)
        DeXState.RainbowChamsEnabled = val
    end)
    
    createColorPicker(VisualsTab, "Self Chams Color", Color3.fromRGB(255, 255, 255), function(val)
        DeXState.SelfChamsColor = val
        if DeXState.SelfChamsEnabled and Players.LocalPlayer.Character then
            removeChams(Players.LocalPlayer.Character)
            applyChams(Players.LocalPlayer.Character, true)
        end
    end)
    
    createColorPicker(VisualsTab, "Other Chams Color", Color3.fromRGB(255, 0, 0), function(val)
        DeXState.OtherChamsColor = val
        if DeXState.OtherChamsEnabled then
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= Players.LocalPlayer and player.Character then
                    removeChams(player.Character)
                    applyChams(player.Character, false)
                end
            end
        end
    end)
    
    createToggle(VisualsTab, "Nebula Theme", false, function(val)
        DeXState.nebulaEnabled = val
        if val then
            local b = Instance.new("BloomEffect", Lighting)
            b.Name = "NebulaBloom"
            b.Intensity = 0.7
            b.Size = 24
            b.Threshold = 1

            local c = Instance.new("ColorCorrectionEffect", Lighting)
            c.Name = "NebulaColorCorrection"
            c.Saturation = 0.5
            c.Contrast = 0.2
            c.TintColor = Color3.fromRGB(173, 216, 230)

            local a = Instance.new("Atmosphere", Lighting)
            a.Name = "NebulaAtmosphere"
            a.Density = 0.4
            a.Offset = 0.25
            a.Glare = 1
            a.Haze = 2
            a.Color = Color3.fromRGB(25, 25, 112)
            a.Decay = 1

            Lighting.Aambient = Color3.fromRGB(173, 216, 230)
            Lighting.OutdoorAmbient = Color3.fromRGB(173, 216, 230)
            Lighting.FogStart = 100
            Lighting.FogEnd = 500
            Lighting.FogColor = Color3.fromRGB(173, 216, 230)
        else
            for _, effectName in pairs({"NebulaBloom", "NebulaColorCorrection", "NebulaAtmosphere"}) do
                local effect = Lighting:FindFirstChild(effectName)
                if effect then
                    effect:Destroy()
                end
            end
            Lighting.Ambient = Color3.new(0, 0, 0)
            Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
            Lighting.FogStart = 0
            Lighting.FogEnd = 1000
            Lighting.FogColor = Color3.new(1, 1, 1)
        end
    end)
    
    createToggle(VisualsTab, "Hit Sound", false, function(val)
        DeXState.hitSoundEnabled = val
    end)
    
    createDropdown(VisualsTab, "Hit Sound", {"Neverlose", "Bameware", "Cod", "Minecraft", "Bubble", "RIFK7", "Gamesense", "Rust"}, "Neverlose", function(val)
        if sounds[val] then
            DeXState.hitSoundId = sounds[val]
            hitSound.SoundId = sounds[val]
        end
    end)
    
    -- Movement Tab
    yOffset = 0
    createToggle(MovementTab, "Speed", false, function(val)
        DeXState.isSpeedActive = val
        setWalkSpeed(val and DeXState.flySpeed or (getgenv().originalWalkSpeed or 16))
    end)
    
    createSlider(MovementTab, "Speed Multiplier", 1, 100, 50, function(val)
        DeXState.flySpeed = val
        if DeXState.isSpeedActive then
            setWalkSpeed(val)
        end
    end)
    
    createToggle(MovementTab, "Fly", false, function(val)
        DeXState.isFlyActive = val
        if not val then
            if flyBodyVelocity then
                flyBodyVelocity:Destroy()
                flyBodyVelocity = nil
            end
            if flyBodyGyro then
                flyBodyGyro:Destroy()
                flyBodyGyro = nil
            end
        end
    end)
    
    createToggle(MovementTab, "NoClip", false, function(val)
        DeXState.isNoClipActive = val
    end)
    
    createToggle(MovementTab, "Target Strafe", false, function(val)
        DeXState.strafeEnabled = val
    end)
    
    createSlider(MovementTab, "Strafe Speed", 10, 100, 50, function(val)
        DeXState.strafeSpeed = val
    end)
    
    createSlider(MovementTab, "Strafe Radius", 1, 20, 5, function(val)
        DeXState.strafeRadius = val
    end)
    
    createDropdown(MovementTab, "Strafe Mode", {"Horizontal", "Vertical", "Random"}, "Horizontal", function(val)
        DeXState.strafeMode = val
    end)
    
    -- Keybinds Tab
    yOffset = 0
    createKeybind(KeybindsTab, "AimLock Keybind", DeXState.aimLockKeybind, function(key)
        DeXState.aimLockKeybind = key
        setupKeybinds()
    end)
    
    createKeybind(KeybindsTab, "Menu Toggle", DeXState.menuKeybind, function(key)
        DeXState.menuKeybind = key
    end)
    
    createKeybind(KeybindsTab, "Fly Toggle", DeXState.flyKeybind, function(key)
        DeXState.flyKeybind = key
        setupKeybinds()
    end)
    
    createKeybind(KeybindsTab, "Speed Toggle", DeXState.speedKeybind, function(key)
        DeXState.speedKeybind = key
        setupKeybinds()
    end)
    
    createKeybind(KeybindsTab, "NoClip Toggle", DeXState.noclipKeybind, function(key)
        DeXState.noclipKeybind = key
        setupKeybinds()
    end)
    
    createKeybind(KeybindsTab, "Strafe Toggle", DeXState.strafeKeybind, function(key)
        DeXState.strafeKeybind = key
        setupKeybinds()
    end)
    
    -- Settings Tab
    yOffset = 0
    local unloadButton = Instance.new("TextButton")
    unloadButton.Name = "UnloadButton"
    unloadButton.Parent = SettingsTab
    unloadButton.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
    unloadButton.BorderSizePixel = 0
    unloadButton.Size = UDim2.new(1, -20, 0, 50)
    unloadButton.LayoutOrder = yOffset
    unloadButton.Font = Enum.Font.GothamBold
    unloadButton.Text = "Unload DeX"
    unloadButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    unloadButton.TextSize = 16

    local UnloadCorner = Instance.new("UICorner")
    UnloadCorner.CornerRadius = UDim.new(0, 8)
    UnloadCorner.Parent = unloadButton

    unloadButton.MouseButton1Click:Connect(function()
        for _, connection in pairs(connections) do
            if connection then
                connection:Disconnect()
            end
        end
        
        for _, connection in pairs(keybindConnections) do
            if connection then
                connection:Disconnect()
            end
        end
        
        if fovcircle then
            fovcircle:Remove()
        end
        
        clearAllChams()
        clearESP()
        
        if DeXState.nebulaEnabled then
            for _, effectName in pairs({"NebulaBloom", "NebulaColorCorrection", "NebulaAtmosphere"}) do
                local effect = Lighting:FindFirstChild(effectName)
                if effect then
                    effect:Destroy()
                end
            end
            Lighting.Ambient = Color3.new(0, 0, 0)
            Lighting.OutdoorAmbient = Color3.new(0, 0, 0)
            Lighting.FogStart = 0
            Lighting.FogEnd = 1000
            Lighting.FogColor = Color3.new(1, 1, 1)
        end
        
        for _, s in pairs(soundPool) do
            s:Stop()
            s:Destroy()
        end
        
        setWalkSpeed(getgenv().originalWalkSpeed or 16)
        if flyBodyVelocity then
            flyBodyVelocity:Destroy()
            flyBodyVelocity = nil
        end
        if flyBodyGyro then
            flyBodyGyro:Destroy()
            flyBodyGyro = nil
        end
        
        ScreenGui:Destroy()
        print("DeX unloaded successfully!")
    end)

    -- Dragging functionality
    local dragging = false
    local dragStart = nil
    local startPos = nil

    TitleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    CloseButton.MouseButton1Click:Connect(function()
        MainFrame.Visible = false
    end)

    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if not gameProcessed and input.KeyCode == DeXState.menuKeybind then
            MainFrame.Visible = not MainFrame.Visible
        end
    end)

    return ScreenGui
end

local function setupSilentAim()
    local mt = getrawmetatable(game)
    local oldNamecall

    if hookmetamethod then  
        oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)  
            local method = getnamecallmethod()  
            local args = {...}  
              
            if SilentAimSettings.Enabled and self == workspace and method then  
                if method == "FindPartOnRay" or method == "Raycast" then  
                    if not CalculateChancePercentage(SilentAimSettings.HitChance) then  
                        return oldNamecall(self, unpack(args))  
                    end

                    local targetPart = getClosestPlayerForSilentAim()  
                    if targetPart then  
                        local origin  
                        if SilentAimSettings.BulletTP then  
                            origin = targetPart.CFrame.Position + Vector3.new(0, 0, 1)  
                        else  
                            origin = Camera.CFrame.Position  
                        end  
                        local direction = (targetPart.Position - origin).Unit * 1000

                        if method == "FindPartOnRay" then  
                            return oldNamecall(self, Ray.new(origin, direction))  
                        elseif method == "Raycast" then  
                            local raycastParams = args[1]  
                            if raycastParams then  
                                raycastParams.Origin = origin  
                                raycastParams.Direction = direction  
                            end  
                            return oldNamecall(self, raycastParams)  
                        end  
                    end  
                end  
            end  
            return oldNamecall(self, unpack(args))  
        end))  
    elseif mt and setreadonly then  
        setreadonly(mt, false)  
        oldNamecall = mt.__namecall  
          
        mt.__namecall = newcclosure(function(self, ...)  
            local method = getnamecallmethod()  
            local args = {...}  
              
            if SilentAimSettings.Enabled and self == workspace and method then  
                if method == "FindPartOnRay" or method == "Raycast" then  
                    if not CalculateChancePercentage(SilentAimSettings.HitChance) then  
                        return oldNamecall(self, unpack(args))  
                    end

                    local targetPart = getClosestPlayerForSilentAim()  
                    if targetPart then  
                        local origin  
                        if SilentAimSettings.BulletTP then  
                            origin = targetPart.CFrame.Position + Vector3.new(0, 0, 1)  
                        else  
                            origin = Camera.CFrame.Position  
                        end  
                        local direction = (targetPart.Position - origin).Unit * 1000

                        if method == "FindPartOnRay" then  
                            return oldNamecall(self, Ray.new(origin, direction))  
                        elseif method == "Raycast" then  
                            local raycastParams = args[1]  
                            if raycastParams then  
                                raycastParams.Origin = origin  
                                raycastParams.Direction = direction  
                            end  
                            return oldNamecall(self, raycastParams)  
                        end  
                    end  
                end  
            end  
            return oldNamecall(self, unpack(args))  
        end)  
          
        setreadonly(mt, true)  
    else  
        print("Silent Aim: Advanced hooking not available, using basic mode")  
          
        connections[#connections + 1] = UserInputService.InputBegan:Connect(function(input, gameProcessed)  
            if not gameProcessed and input.UserInputType == Enum.UserInputType.MouseButton1 and SilentAimSettings.Enabled then  
                if CalculateChancePercentage(SilentAimSettings.HitChance) then  
                    local targetPart = getClosestPlayerForSilentAim()  
                    if targetPart then  
                        local originalCFrame = Camera.CFrame  
                          
                        Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, targetPart.Position)  
                          
                        RunService.Heartbeat:Wait()  
                        Camera.CFrame = originalCFrame  
                    end  
                end  
            end  
        end)  
    end  
end

connections[#connections + 1] = RunService.RenderStepped:Connect(function()
    if not DeXState.masterToggle then return end

    if DeXState.aimLockEnabled and DeXState.lockEnabled and DeXState.isLockedOn and DeXState.targetPlayer and DeXState.targetPlayer.Character then  
        local partName = DeXState.bodyPartSelected  
        local part = DeXState.targetPlayer.Character:FindFirstChild(partName)  
        if part and DeXState.targetPlayer.Character:FindFirstChildOfClass("Humanoid").Health > 0 then  
            local predictedPosition = part.Position + (part.AssemblyLinearVelocity * DeXState.predictionFactor)  
              
            if DeXState.antiLockEnabled then  
                if DeXState.resolverMethod == "Recalculate" then  
                    predictedPosition = predictedPosition + part.AssemblyLinearVelocity * DeXState.resolverIntensity  
                elseif DeXState.resolverMethod == "Randomize" then  
                    predictedPosition = predictedPosition + Vector3.new(  
                        (math.random() * 2 - 1) * DeXState.resolverIntensity,  
                        (math.random() * 2 - 1) * DeXState.resolverIntensity,  
                        (math.random() * 2 - 1) * DeXState.resolverIntensity)  
                elseif DeXState.resolverMethod == "Invert" then  
                    predictedPosition = predictedPosition - (part.AssemblyLinearVelocity * DeXState.resolverIntensity * 2)  
                end  
            end  
              
            if DeXState.DesyncEnabled and DeXState.Desync then  
                local desyncOffset = Vector3.new(  
                    math.sin(tick() * 5) * DeXState.reverseResolveIntensity,  
                    0,  
                    math.cos(tick() * 5) * DeXState.reverseResolveIntensity  
                )  
                predictedPosition = predictedPosition + desyncOffset  
            end  
              
            local currentCameraPosition = Camera.CFrame.Position  
            local targetCFrame = CFrame.lookAt(currentCameraPosition, predictedPosition)  
            Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, 1 - DeXState.smoothingFactor)  
        else  
            DeXState.isLockedOn = false  
            DeXState.targetPlayer = nil  
        end  
    end  
end)

connections[#connections + 1] = RunService.RenderStepped:Connect(function()
    if fovcircle.Visible then
        local mouse = UserInputService:GetMouseLocation()
        fovcircle.Position = Vector2.new(mouse.X, mouse.Y)
    end
end)

connections[#connections + 1] = RunService.Stepped:Connect(function()
    handleMovement()
    handleStrafe()
end)

connections[#connections + 1] = RunService.RenderStepped:Connect(function()
    updateESP()
    updateChams()
end)

connections[#connections + 1] = Players.LocalPlayer.CharacterAdded:Connect(function(char)
    if DeXState.SelfChamsEnabled then
        task.wait(1)
        applyChams(char, true)
    end
end)

connections[#connections + 1] = Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        task.wait(1)
        createESP(player)
        if DeXState.OtherChamsEnabled then
            applyChams(char, false)
        end
    end)

    if player.Character then  
        createESP(player)
        if DeXState.OtherChamsEnabled then
            applyChams(player.Character, false)
        end
    end
end)

connections[#connections + 1] = Players.PlayerRemoving:Connect(function(player)
    if espObjects[player] then
        if espObjects[player].box then espObjects[player].box:Remove() end
        if espObjects[player].name then espObjects[player].name:Remove() end
        if espObjects[player].healthBarOutline then espObjects[player].healthBarOutline:Remove() end
        if espObjects[player].healthBar then espObjects[player].healthBar:Remove() end
        if espObjects[player].tracer then espObjects[player].tracer:Remove() end
        espObjects[player] = nil
    end
    
    if player.Character and chamsObjects[player.Character] then
        removeChams(player.Character)
    end
end)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= Players.LocalPlayer then
        if player.Character then
            createESP(player)
            if DeXState.OtherChamsEnabled then
                applyChams(player.Character, false)
            end
        end
    end
end

pcall(setupSilentAim)

local UI = createUI()

setupKeybinds()

task.wait(0.5)

print("==========================================")
print("DeX DaHood UI - Version 0.0.1 Loaded!")
print("==========================================")
print("Features Included:")
print("â€¢ Complete AimLock with Anti-Lock/Resolver")
print("â€¢ Advanced Silent Aim with multiple methods")
print("â€¢ Full ESP system with customizable options")
print("â€¢ Self Chams with rainbow and color options")
print("â€¢ Other Player Chams with wall visibility")
print("â€¢ Advanced movement (Speed, Fly, NoClip, Strafe)")
print("â€¢ Hit Sound system with multiple sounds")
print("â€¢ Customizable keybinds for all features")
print("â€¢ Nebula theme and lighting effects")
print("â€¢ Adonis anti-cheat bypass")
print("==========================================")
print("Default Keybinds:")
print("â€¢ Menu Toggle: " .. DeXState.menuKeybind.Name)
print("â€¢ AimLock: " .. DeXState.aimLockKeybind.Name)
print("â€¢ Fly: " .. DeXState.flyKeybind.Name)
print("â€¢ Speed: " .. DeXState.speedKeybind.Name)
print("â€¢ NoClip: " .. DeXState.noclipKeybind.Name)
print("â€¢ Strafe: " .. DeXState.strafeKeybind.Name)
print("==========================================")
print("All keybinds can be changed in the Keybinds tab!")
print("Enjoy the complete destroy experience <3!")
